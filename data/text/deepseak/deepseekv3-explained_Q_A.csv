user_input,reference_contexts,reference,synthesizer_name
What are the similarities between the DeepSeek-V3 model and standard LLMs as discussed in the paper?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model, while presenting new conceptualizations, still resembles the core principles of standard Transformers and well-known large language models (LLMs).",single_hop_specifc_query_synthesizer
How does the DeepSeek-V3 model achieve its performance and economical training as an open source model?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model achieves incredible performance and economical training through various features that were invented and applied in its development. While the presentation of the model may seem complicated to those unfamiliar with the new conceptualization by DeepSeek, its core principle resembles that of the standard Transformer and well-known large language models (LLMs). A general knowledge of previously released models like LLaMA is also beneficial for understanding DeepSeek-V3.",single_hop_specifc_query_synthesizer
How does the DeepSeek-V3 model relate to the standard Trensformer and large language models?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']",The DeepSeek-V3 model's core principle resembles that of the standard Transformer and well-known large language models (LLMs). This connection is essential for understanding the features and performance of the DeepSeek-V3 model.,single_hop_specifc_query_synthesizer
What is the significance of LLaMA in understanding the DeepSeek-V3 model's architecture and performance?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","LLaMA is significant because it provides general knowledge of previously released large language models, which is incredibly helpful for understanding the core principles of the DeepSeek-V3 model, as it resembles the standard Transformer and well-known LLMs.",single_hop_specifc_query_synthesizer
How does the DeepSeek-V3 model relate to the standard Transformer architecture?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']",The DeepSeek-V3 model's core principle resembles that of the standard Transformer and well-known large language models (LLMs).,single_hop_specifc_query_synthesizer
What similarities do LLMs share with the DeepSeek-V3 model according to the paper?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']",The core principle of the DeepSeek-V3 model resembles that of the standard Transformer and well-known LLMs.,single_hop_specifc_query_synthesizer
What are the key features of the DeepSeek-V3 model that contribute to its performance and training efficiency?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model achieves incredible performance and economical training through various features that were invented and applied in its development. While the presentation of the model may seem complicated to those unfamiliar with its new conceptualization, its core principle resembles that of the standard Transformer and well-known large language models (LLMs). A general knowledge of previously released models like LLaMA is also beneficial for understanding DeepSeek.",single_hop_specifc_query_synthesizer
How does the DeepSeek-V3 model achieve its performance and training efficiency according to the paper review?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model achieves incredible performance and economical training as an open source model through various features that were invented and applied in its construction. While the presentation of the model may seem complicated to those unfamiliar with the new conceptualization, its core principle resembles that of the standard Transformer and well-known large language models (LLMs). A general knowledge of previously released models like LLaMA is also beneficial for understanding DeepSeek.",single_hop_specifc_query_synthesizer
How DeepSeek-V3 model get good performance and cheap training?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek-V3 model achieves incredible performance and economical training as an open source model through various features that were invented and applied in its construction. Its core principle resembles that of the standard Transformer and well-known LLMs, making it beneficial to have general knowledge of previously released large language models like LLaMA.",single_hop_specifc_query_synthesizer
How DeepSeek-V3 model can do good performance and cheap training as open source model?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model achieves incredible performance and economical training as an open source model through various features that were invented and applied in its construction. While the presentation of the model may seem complicated to those unfamiliar with the new conceptualization, its core principle resembles that of the standard Transformer and well-known large language models (LLMs). Having general knowledge of previously released models like LLaMA is incredibly helpful in understanding DeepSeek.",single_hop_specifc_query_synthesizer
What are the key features of the DeepSeek-V3 model that contribute to its performance and training efficiency?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model achieves incredible performance and economical training through various features that were invented and applied in its architecture. While the presentation of the model may seem complicated to those unfamiliar with its new conceptualization, its core principle resembles that of the standard Transformer and well-known large language models (LLMs). A general knowledge of previously released models like LLaMA is also beneficial for understanding DeepSeek.",single_hop_specifc_query_synthesizer
What is the core principle of the Transformer as mentioned in the context?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The core principle of the Transformer still resembles that of the standard Transformer and well-known LLMs, as indicated in the context.",single_hop_specifc_query_synthesizer
What are the key features of the DeepSeek-V3 model that contribute to its performance and economical training?,"['author - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model achieves incredible performance and economical training through various features that were invented and applied in its development. While the model's presentation may seem complicated to those unfamiliar with its new conceptualization, its core principle resembles that of the standard Transformer and well-known large language models (LLMs). A general knowledge of previously released LLMs, such as LLaMA, is beneficial for understanding the DeepSeek model.",single_hop_specifc_query_synthesizer
What are the key improvements introduced in the V2 model compared to its predecessor?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The V2 model introduced several key improvements, including a more sophisticated attention mechanism and Feed-Forward Network structure. It utilized Multi-Head Latent Attention (MLA) to enhance speed and memory usage by compressing input vectors, and it implemented a mixture of experts approach called DeekSeekMoE, allowing specialized experts to handle specific domains of tokens, improving overall performance.",single_hop_specifc_query_synthesizer
How does the Feed-Forward Network function in the DeekSeek-V3 model?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","In the DeekSeek-V3 model, the Feed-Forward Network is split into multiple experts, referred to as DeekSeekMoE. Each expert specializes in a certain domain, allowing for improved performance by focusing on specific groups of tokens. Depending on the input sequence, certain experts are activated to contribute to the output, while shared experts act as generalists for all token types.",single_hop_specifc_query_synthesizer
"Can you elaborate on the architectural advancements of DeekSeek-V3 compared to its predecessor, particularly in terms of the Multi-Head Latent Attention and the DeekSeekMoE components?","['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeekSeek-V3 model builds upon the architecture of the previous V2 model, incorporating enhancements in its Multi-Head Latent Attention (MLA) and the DeekSeekMoE components. The MLA improves speed and memory usage by compressing the input vector, allowing for efficient data processing while preserving essential information. This is achieved through techniques like Principal Component Analysis (PCA) and variational autoencoders, which compress and reconstruct data. Additionally, the DeekSeekMoE introduces a novel approach by splitting the Feed-Forward Network into multiple experts, each specializing in specific domains of tokens. This mixture of experts allows for more efficient processing, as only the relevant experts are activated based on the input sequence, enhancing the model's performance. Overall, these advancements contribute to a more economical KV cache and improved model efficiency.",single_hop_specifc_query_synthesizer
How does PCA contribute to the efficiency of the Multi-Head Latent Attention in the DeekSeek-V3 model?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","Principal Component Analysis (PCA) is a well-known technique that reduces the dimension of data while maintaining variance to retain its information. In the context of the Multi-Head Latent Attention (MLA) in the DeekSeek-V3 model, PCA contributes to efficiency by compressing the input vector, which improves speed and memory usage in the attention block. This compression allows the model to store a compressed vector for the KV cache, enhancing both speed by reducing data copying and memory efficiency by utilizing a smaller compressed vector.",single_hop_specifc_query_synthesizer
What are the main improvements of V2 model compared to its predecessor?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The V2 model has several improvements over its predecessor, including a more sophisticated attention mechanism and Feed-Forward Network. The attention block in V2 uses Multi-Head Latent Attention (MLA) to enhance speed and memory usage by compressing the input vector. Additionally, the Feed-Forward Network is split into multiple experts, known as DeekSeekMoE, allowing specialization in certain domains to improve performance.",single_hop_specifc_query_synthesizer
What Multi-Head Latent Attention do?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","Multi-Head Latent Attention (MLA) improves the speed and memory usage in the attention block by compressing the input vector. It allows data to be compressed into a lower dimension while preserving the information it contains, using techniques like Principal Component Analysis (PCA). In the latent diffusion model, input data is compressed by a variational autoencoder and reconstructed in its initial dimension. MLA applies this principle to compress and decompress the input data, enhancing both speed and memory efficiency by storing a compressed vector for the KV cache.",single_hop_specifc_query_synthesizer
What is the significance of principal component analysis in the context of the DeekSeek-V3 model?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","Principal component analysis (PCA) is a well-known technique that reduces the dimension of data while maintaining variance to retain its information. In the context of the DeekSeek-V3 model, PCA is significant as it allows for the compression of input data into a lower dimension while preserving essential information. This principle is applied in the Multi-Head Latent Attention (MLA) component of the model, which improves speed and memory usage in the attention block by compressing the input vector.",single_hop_specifc_query_synthesizer
Can you explain how V2 model influenced the architecture of DeekSeek-V3 and what are the key improvements made?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeekSeek-V3 model has inherited most parts of the model from the previous V2 model. The V2 paper elaborated on these parts, highlighting the principles upon which the V3 model was built. While V3 uses the structure of the ordinary transformer block like Llama, it incorporates more sophisticated attention and Feed-Forward Network mechanisms to enhance model performance. Key improvements include the introduction of Multi-Head Latent Attention (MLA), which improves speed and memory usage by compressing the input vector, and the DeekSeekMoE, which splits the Feed-Forward Network into multiple experts to specialize in certain domains, thus improving performance. Additionally, the model employs a sequential Multi-Token Prediction (MTP) approach to enhance efficiency and speed of convergence during training.",single_hop_specifc_query_synthesizer
Can you explain the role of PCA in the context of the DeekSeek-V3 model architecture?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","In the context of the DeekSeek-V3 model architecture, Principal Component Analysis (PCA) is a well-known technique used to reduce the dimension of the data while maintaining variance to retain its information. It is mentioned that the Multi-Head Latent Attention (MLA) improves speed and memory usage in the attention block by compressing the input vector, and PCA is one of the techniques that can achieve this compression by transforming the data into a lower dimension.",single_hop_specifc_query_synthesizer
What are the key components of DeekSeek-V3 model architecture?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The key components of the DeekSeek-V3 model architecture include Multi-Head Latent Attention (MLA) and DeepSeekMoE. MLA improves speed and memory usage in the attention block by compressing the input vector, while DeepSeekMoE splits the Feed-Forward Network into multiple experts, allowing specialization in certain domains to enhance performance.",single_hop_specifc_query_synthesizer
What is DeekSeek-V3 and how does it improve model performance?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeekSeek-V3 is a model that builds upon the architecture of its predecessor, V2, utilizing an ordinary transformer block structure similar to Llama. It enhances performance through sophisticated attention mechanisms and a Feed-Forward Network split into multiple experts, known as DeekSeekMoE. The Multi-Head Latent Attention (MLA) compresses input data to improve speed and memory efficiency, while the DeekSeekMoE allows for specialization among experts based on input tokens, optimizing output generation. Additionally, the model employs a sequential Multi-Token Prediction (MTP) approach to enhance learning efficiency.",single_hop_specifc_query_synthesizer
What role does DeepSeekMoE play in the DeepSeek-V3 model architecture?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeekMoE is a specialized Feed-Forward Network that is split into multiple experts, allowing each expert to focus on a specific domain of tokens. This mixture of experts improves performance by activating only the relevant experts based on the input sequence, rather than relying on a single large FFN. Each expert has a centroid vector that represents the type of input tokens it specializes in, and a scoring mechanism determines which experts to activate for generating the output.",single_hop_specifc_query_synthesizer
What are the key components of the DeekSeek-V3 model architecture?,"['Model Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The key components of the DeekSeek-V3 model architecture include the Multi-Head Latent Attention (MLA) and DeepSeekMoE. The MLA improves speed and memory usage in the attention block by compressing the input vector, while DeepSeekMoE splits the Feed-Forward Network into multiple experts, allowing specialization in certain domains for improved performance.",single_hop_specifc_query_synthesizer
How does DeepSeek's approach to training LLMs differ from traditional methods?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","DeepSeek's approach to training LLMs involves innovative methods such as the DualPipe technique, which combines the forward process and the backward for input to reduce communication between GPUs. This is particularly important when using weaker H800 GPUs, as it allows for continuous data processing without idle time. Additionally, DeepSeek employs mixed precision training, where precision is reduced in less significant parts of the model while maintaining high precision for critical computations. This contrasts with traditional methods that may not optimize for communication efficiency or precision management.",single_hop_specifc_query_synthesizer
"How has the U.S. export restrictions on GPUs impacted the training of machine learning models, particularly in the context of DeepSeek's innovations?","['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","The U.S. did not export great GPUs like the NVIDIA H100 to China, which led DeepSeek researchers to devise innovative methods to accelerate model training using the weaker H800 GPUs. Their success in this area caused NVIDIA’s stock price to briefly plunge, as it suggested that high-performance GPUs might no longer be necessary for training large language models (LLMs). The DeepSeek model was trained on 2048 H800 GPUs, and communication between these GPUs accounted for a significant portion of the training time. To address this, DeepSeek invented a method to reduce the 'bubble'—the waiting time that occurs when GPUs wait for data to be copied from one another—by combining forward and backward processes in their DualPipe approach, thus enhancing training efficiency despite the limitations of the H800 GPUs.",single_hop_specifc_query_synthesizer
How does FP8 quantization impact the training efficiency of the DeepSeek model?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","In the DeepSeek model, FP8 quantization is utilized to improve training and memory efficiency while maintaining model accuracy. It allows for the reduction of precision in parts of the model that are less significant for accuracy, particularly in heavy computations like matrix multiplication. However, using lower precision like FP8 can lead to overflow and underflow issues. To address this, DeepSeek implemented Fine-Grained Quantization, where values are grouped with individual scaling factors, thus preventing overflow and underflow. Additionally, to mitigate the accumulation of small errors, intermediate values are stored in high precision when a certain number of values is reached, ensuring that errors do not accumulate significantly.",single_hop_specifc_query_synthesizer
How DeepSeek make training faster with H800 GPUs and what is the role of DualPipe in this process?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. They succeeded in reducing communication between GPUs to accelerate training. The DualPipe method combines the forward process and the backward for input by initiating training data from two devices in opposite directions. This allows devices to start training with other batch data simultaneously, reducing idle time and communication delays, thus enhancing training efficiency.",single_hop_specifc_query_synthesizer
What is DeepSeek-V3 and how does it improve training efficiency?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","DeepSeek-V3 is a model that enhances training efficiency by reducing communication between GPUs, particularly when using weaker H800 GPUs. It employs a method called DualPipe, which combines the forward process and the backward for input by initiating training data from two devices in opposite directions. This allows for continuous data processing and minimizes idle time for GPUs. Additionally, DeepSeek-V3 utilizes mixed precision training, where precision is reduced in less significant parts of the model while maintaining high precision for critical computations, thus improving training and memory efficiency.",single_hop_specifc_query_synthesizer
What innovative methods did DeepSeek researchers use to accelerate model training with the weaker H800 GPUs instead of the NVIDIA H100?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","DeepSeek researchers devised innovative methods to accelerate model training using the weaker H800 GPUs due to the lack of access to the NVIDIA H100. They focused on enhancing networking between GPUs to reduce training time, addressing the inefficiencies caused by waiting times, known as 'bubbles.' They invented a method called DualPipe, which combines the forward process and the backward for input by initiating training data from two devices in opposite directions. This approach allows for continuous copying of data and reduces communication between GPUs, thereby accelerating training despite the limitations of the H800 GPUs.",single_hop_specifc_query_synthesizer
Why did the U.S. not export great GPUs like the NVIDIA H100 to China?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","The U.S. did not export great GPUs like the NVIDIA H100 to China, which led DeepSeek researchers to devise innovative methods to accelerate model training using the weaker H800 GPUs.",single_hop_specifc_query_synthesizer
What is the role of LLM in mixed precision training?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']",Mixed precision training is a prevalent technique of LLM to improve training and memory efficiency while maintaining model accuracy. It involves finding parts of the model that are less significant for accuracy and reducing the precision of those parts.,single_hop_specifc_query_synthesizer
What are the key techniques used in LLM training according to the context?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","The key techniques used in LLM training according to the context include mixed precision training and the innovative DualPipe method. Mixed precision training improves training and memory efficiency while maintaining model accuracy by reducing precision in less significant parts of the model, such as during heavy computations like matrix multiplication. The DualPipe method combines the forward process and the backward for input by initiating training data from two devices in opposite directions, which reduces communication between GPUs and accelerates training.",single_hop_specifc_query_synthesizer
How did DeepSeek researchers utilize the H800 GPUs for model training?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs, as the U.S. did not export great GPUs like the NVIDIA H100 to China. They succeeded in training their model on 2048 H800 GPUs by enhancing networking between GPUs to reduce training time and minimizing the waiting time, known as a 'bubble', that occurs when GPUs wait for data to be copied from other GPUs.",single_hop_specifc_query_synthesizer
What challenges did DeepSeek face with the NVIDIA H100 not being exported to China?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs due to the U.S. not exporting great GPUs like the NVIDIA H100 to China. This situation led to a brief plunge in NVIDIA’s stock price, as it was believed that high-performance GPUs would no longer be necessary for training large language models.",single_hop_specifc_query_synthesizer
How has the lack of access to high-performance GPUs like the NVIDIA H100 in China influenced the training techniques developed by DeepSeek researchers?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","Due to the U.S. not exporting high-performance GPUs like the NVIDIA H100 to China, DeepSeek researchers had to innovate and devise methods to accelerate model training using the weaker H800 GPUs. Their success in this area led to a brief plunge in NVIDIA's stock price, as it suggested that high-performance GPUs might no longer be necessary for training large language models (LLMs). The researchers focused on enhancing networking between GPUs to reduce training time, addressing inefficiencies caused by waiting times, known as 'bubbles,' during simultaneous GPU usage. They invented a method called DualPipe to minimize these bubbles by combining the forward process and the backward for input, allowing for more efficient data processing and communication between GPUs.",single_hop_specifc_query_synthesizer
How does DeepSeek utilize the DualPipe method to enhance model training efficiency with H800 GPUs?,"['Infrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.']","DeepSeek's DualPipe method enhances model training efficiency by combining the forward process and the backward for input process. This is achieved by initiating training data from two devices in opposite directions, allowing for continuous data processing and reducing idle time for GPUs. For instance, while a conventional training plan would leave device 7 idle, waiting for batch 0 to be copied, DualPipe enables device 7 to start training with other batch data simultaneously. This innovative approach minimizes communication between GPUs, which is crucial given the limitations of the weaker H800 GPUs, thereby accelerating the overall training process.",single_hop_specifc_query_synthesizer
How does the Chinese government affect AI model performance?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']",The performance of a good AI model may be undermined by the censorship and suppression of the Chinese government.,single_hop_specifc_query_synthesizer
How does the censorship and suppression of the Chines government impact AI model performance according to the context?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","The context suggests that the performance of a good AI model may be undermined by the censorship and suppression of the Chinese government, implying that such restrictions could negatively affect the development and effectiveness of AI models.",single_hop_specifc_query_synthesizer
Can you explain the innovative features of DeepSeek that enhance its training efficiency and model performance?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","DeepSeek incorporates several innovative features to enhance training efficiency and model performance. It employs reinforcement learning after supervised fine-tuning, utilizing both rule-based and model-based reward models to provide feedback to the model. The rule-based reward model is applied to specific domains like math and logical reasoning, while the model-based reward model assesses answers against ground-truth answers when no specific rules are available. Additionally, DeepSeek includes a chain-of-thought approach to rewards, contrasting with conventional models that only consider final answers. The DeepSeek-V3 model utilizes Group Relative Policy Optimization (GRPO) to maximize the objective by updating the policy model based on normalized rewards. This approach reinforces correct outputs and minimizes deviations from the base model using KL divergence and an epsilon parameter, ensuring that the model retains essential language understanding and knowledge. Overall, DeepSeek offers a cost-effective training solution that is open-source, allowing AI researchers to implement its innovative methods in their own models.",single_hop_specifc_query_synthesizer
How might the Chinese government impact AI research and development?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']",The performance of a good AI model may be undermined by the censorship and suppression of the Chinese government.,single_hop_specifc_query_synthesizer
How does the Chinese government affect AI model performance?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']",The performance of a good AI model may be undermined by the censorship and suppression of the Chinese government.,single_hop_specifc_query_synthesizer
What does GRPO stand for in the context of DeepSeek?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","GRPO stands for Group Relative Policy Optimization, which is an algorithm adopted by the DeepSeek-V3 model to maximize the objective by updating the policy model.",single_hop_specifc_query_synthesizer
What innovative techniques does DeepSeek employ to enhance reinforcement learning?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","DeepSeek employs several innovative techniques to enhance reinforcement learning, including the use of both rule-based and model-based reward models. The rule-based reward model is applied to questions with specific rules, such as math and logical reasoning problems, while the model-based reward model determines if the answer matches the ground-truth when no specific rule is available. Additionally, DeepSeek incorporates chain-of-thought into the reward system, which is a departure from conventional models that only consider the final reward based on the answer. The DeepSeek-V3 model also utilizes Group Relative Policy Optimization (GRPO) to maximize the objective by updating the policy model based on the reward, ensuring that the model does not deviate significantly from the initial base model through the use of KL divergence and an epsilon parameter.",single_hop_specifc_query_synthesizer
How does DeepSeek compare to OpenAI in terms of training efficiency?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","DeepSeek is more economical to train than the OpenAI model, offering great opportunities for efficient training with cheaper GPUs. However, it is unclear if its performance exceeds that of OpenAI.",single_hop_specifc_query_synthesizer
How does reinforcement learning enhance the performance of the DeepSeek model?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","Reinforcement learning enhances the performance of the DeepSeek model by building and training a reward model that provides feedback to the model, determining the direction of learning. The model employs both rule-based and model-based reward models to verify answers and assess correctness. Additionally, the inclusion of chain-of-thought in the reward system, along with the Group Relative Policy Optimization (GRPO) algorithm, allows for effective policy updates based on normalized rewards, thereby improving the model's reasoning capability and overall performance.",single_hop_specifc_query_synthesizer
What are the key components and techniques involved in Reinforcement Learning as implemented in the DeepSeek model?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","Reinforcement Learning in the DeepSeek model involves building and training a reward model that provides feedback to the model and determines the direction of learning. Two types of reward models are employed: the rule-based reward model, which applies specific rules to verify the correctness of answers in domains like math and logical reasoning, and the model-based reward model, which assesses whether answers match the ground-truth when no specific rule is available. Additionally, DeepSeek incorporates chain-of-thought into the reward system, contrasting with conventional models that only consider final rewards. The model also utilizes Group Relative Policy Optimization (GRPO) to maximize the objective by updating the policy model based on the reward, where the advantage is defined as the normalized reward. The GRPO algorithm employs KL divergence to ensure that the current policy does not deviate significantly from the initial base model, thus maintaining essential language understanding and knowledge. This combination of rule-based and model-based reward models enhances the performance and reasoning capability of the DeepSeek model.",single_hop_specifc_query_synthesizer
"How does the performance of the DeepSeek model compare to that of OpenAI, particularly in terms of training efficiency and cost?","['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","The performance of the DeepSeek-V3 model in comparison to OpenAI is unclear; however, DeepSeek is noted to be significantly more economical to train and is an open-source model. This allows AI researchers to directly utilize DeepSeek models and implement its innovative ideas and designs in their own models. The lower training cost associated with DeepSeek is expected to lead to better model accuracy later on, as it allows for easier scaling of data and models at a reduced cost.",single_hop_specifc_query_synthesizer
What GRPO do in DeepSeek?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","GRPO algorithm maximizes the objective by updating the policy model π based on the reward, enhancing model performance and reasoning capability.",single_hop_specifc_query_synthesizer
What is the role of Reinforcement Learning in the DeepSeek model?,"['Reinforcement Learning After supervised fine-tuning, DeepSeek additionally implemented reinforcement learning. A reward model has to be built and trained for reinforcement learning, which gives feedback to the model and determine the direction of learning. The rule-based reward model(RM) and model-based reward model(RM) were employed. The rule-based RM is applied to the questions with specific rules, such as math problems and LeetCode problems. In these domains, the specific rules are used to verify the correctness of the answers and the questions about logical reasoning are involved. However, for many questions, the answer cannot be verified by a specific rule. In those cases where no rule is provided, the model-based RM determines, whether the answer matches the ground-truth answer. Another innovative idea of DeepSeek is including the chain-of-thought to the reward, whereas conventional models only included final reward based on the answer. DeepSeek-V3 model, as V2 model did, adopted Group Relative POlicy Optimization (GRPO). This GRPO algorithm maximizes the following objective by updating the policy model π. Maximize this objective by updating the weights of the model based on the reward. Advantage is defined as the normalized reward. In LLM case, the policy model π is model itself, and θ is weights of the model. q is question and o is output of the model. We can interpret the policy model(LLM) outputs a probability distribution over tokens, where the policy π(o|q) is a probability of output o given the question q. Therefore, the policy model is LLM itself. If the output o is right answer, we should reinforce the probability of that model makes this output o. So we need to maximize π(o|q) by multiplying advantage(normalized reward). If the output o is correct, the advantage (reward) will be a positive value and the policy will be reinforced. Otherwise, it will be negative and π(o|q) should be minimized. Plus, we have a fine-tuned model as the initial base model and do not want it to go too far from this base model, which might cause model to forget basic language understanding and important knowledge that the model learned during pre-training and fine-tuning. To implement this safety concerns, GRPO algorithm used KL divergence and epsilon parameter. The KL divergence measures the difference between current policy model and reference policy model(initial base model). So the KL divergence term should be minimized to maximized the GRPO objective. And we pick minimum between the original policy and the clipped policy in (1-ε, 1+ε), by which the model cannot deviate too much from 1. So, the current policy cannot differ a lot from the old policy, restricting the effect of reinforcement learning. This GRPO algorithm based on rule-based and model-based reward model enhances model performance and reasoning capability. Conclusion DeepSeek-V3 model offered great opportunity for efficient training with cheaper GPUs. It is unclear that its performance exceeds the OpenAI model, but DeepSeek is way more economical to train and open-source model. AI researchers can directly use DeekSeek models and they can also implement the innovative ideas and designs in their own model, because the new methods of DeepSeek and source code are opened. Seemingly, the DeepSeek researchers have potential to come up with more advanced idea to improve the model performance and efficient training process. In AI development, a lower training cost almost always implies better model accuracy later on, as the data and model can easily be scaled up at a lower cost. I hope that the performance of a good AI model does not have to be undermined by the censorship and suppression of the Chinese government.']","Reinforcement Learning is implemented in the DeepSeek model after supervised fine-tuning. It involves building and training a reward model that provides feedback to the model and determines the direction of learning. The model employs both rule-based and model-based reward models to verify answers and enhance performance. Additionally, the GRPO algorithm is used to maximize the objective by updating the policy model based on the reward, ensuring that the model does not deviate too much from its initial base model.",single_hop_specifc_query_synthesizer
How does the DeepSeek-V3 model utilize innovative techniques to enhance training efficiency and performance?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model enhances training efficiency and performance through several innovative techniques. One key method is the DualPipe approach, which reduces communication between GPUs by allowing simultaneous training of batches in opposite directions. This minimizes the waiting time, or 'bubble,' that occurs when GPUs are idle. Additionally, DeepSeek-V3 employs mixed precision training, where precision is reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter tasks. To address issues of overflow and underflow during quantization, DeepSeek implemented Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating. These techniques collectively contribute to the model's impressive performance and economical training.",multi_hop_specific_query_synthesizer
"What innovative methods did the DeepSeek-V3 model employ to enhance training efficiency and performance, particularly in relation to the challenges posed by using weaker H800 GPUs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model employed several innovative methods to enhance training efficiency and performance, particularly in the context of using weaker H800 GPUs. One significant approach was the introduction of the DualPipe method, which aimed to reduce communication delays between GPUs, known as 'bubbles.' By combining the forward process and the backward for input, the DualPipe allowed for simultaneous training on multiple devices, thereby minimizing idle time and improving overall training speed. Additionally, the model utilized mixed precision training, which involved reducing precision in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. This approach not only improved memory efficiency but also preserved model accuracy. To address issues of overflow and underflow during quantization, DeepSeek implemented Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating significantly. These techniques collectively contributed to the remarkable performance and economical training of the DeepSeek-V3 model.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek-V3 implement to enhance training efficiency and performance, particularly in relation to the challenges posed by using H800 GPUs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek-V3 implemented several innovative methods to enhance training efficiency and performance, particularly when using the weaker H800 GPUs. One key method was the introduction of the DualPipe technique, which reduces communication time between GPUs by allowing simultaneous processing of training data in opposite directions. This approach minimizes idle time for GPUs, thereby accelerating the training process. Additionally, DeepSeek-V3 utilized mixed precision training, where precision was reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. To address issues of overflow and underflow during quantization, DeepSeek employed Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating. These methods collectively contributed to the model's impressive performance and economical training as an open-source model.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement to enhance the training efficiency of LLMs like DeepSeek-V3, and how do these methods relate to the standard Transformer architecture?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek researchers implemented several innovative methods to enhance the training efficiency of LLMs, particularly in the DeepSeek-V3 model. One key method is the DualPipe technique, which reduces communication time between GPUs by allowing simultaneous processing of training data in opposite directions. This approach minimizes the 'bubble' waiting time that occurs when GPUs wait for data to be copied. Additionally, they employed mixed precision training, which optimizes memory and training efficiency by reducing precision in less significant parts of the model while maintaining high precision where necessary. These methods are built upon the core principles of the standard Transformer architecture, which is foundational to many well-known LLMs, ensuring that while the techniques may be advanced, they still align with established concepts in model design.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek-V3 implement to enhance training efficiency and performance, particularly in relation to the challenges posed by using H800 GPUs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek-V3 implemented several innovative methods to enhance training efficiency and performance, particularly when using the weaker H800 GPUs. One key method was the introduction of DualPipe, which reduces communication time between GPUs by allowing simultaneous processing of training data in opposite directions. This approach minimizes the waiting time, or 'bubble,' that occurs when GPUs are idle while waiting for data. Additionally, DeepSeek-V3 utilized mixed precision training, where precision was reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. To address issues of overflow and underflow during quantization, DeepSeek employed Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating significantly. These techniques collectively contributed to the model's impressive performance and economical training as an open-source model.",multi_hop_specific_query_synthesizer
"What innovative methods did the DeepSeek-V3 model implement to achieve economical training and improve performance, particularly in relation to the challenges posed by using weaker H800 GPUs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model implemented several innovative methods to achieve economical training and improve performance despite the challenges posed by using weaker H800 GPUs. One key method was the introduction of the DualPipe technique, which reduced communication time between GPUs by allowing simultaneous processing of training data in opposite directions. This approach minimized the 'bubble' waiting time that occurs when GPUs wait for data to be copied from one to another. Additionally, DeepSeek-V3 utilized mixed precision training, where precision was reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. To address issues of overflow and underflow during quantization, DeepSeek implemented Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating. These methods collectively contributed to the model's impressive performance and efficiency in training.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek implement to enhance the training efficiency of LLMs like DeepSeek-V3, and how do these methods relate to the standard principles of LLMs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek implemented several innovative methods to enhance the training efficiency of LLMs, particularly in the DeepSeek-V3 model. One key method is the DualPipe technique, which reduces communication between GPUs by allowing simultaneous training on multiple devices in opposite directions. This approach minimizes the waiting time, or 'bubble,' that occurs when GPUs wait for data to be copied. Additionally, DeepSeek utilized mixed precision training to improve memory efficiency while maintaining model accuracy. This involves reducing precision in less significant parts of the model, such as during heavy computations like matrix multiplication, while preserving high precision for lighter computations. These methods align with the core principles of standard LLMs, such as those used in the Transformer architecture, by focusing on optimizing training processes and resource utilization.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek-V3 implement to enhance training efficiency and performance, particularly in relation to the challenges posed by using H800 GPUs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek-V3 implemented several innovative methods to enhance training efficiency and performance, particularly when using the weaker H800 GPUs. One key method was the introduction of DualPipe, which reduces communication between GPUs by allowing simultaneous training of different batches in opposite directions. This minimizes idle time for GPUs and accelerates the training process. Additionally, DeepSeek-V3 utilized mixed precision training, where precision was reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. To address issues of overflow and underflow during quantization, DeepSeek employed Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating significantly.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement to enhance the training efficiency of LLMs like DeepSeek-V3, and how do these methods relate to the standard principles of LLMs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek researchers implemented several innovative methods to enhance the training efficiency of LLMs, particularly in the DeepSeek-V3 model. One key method is the DualPipe technique, which reduces communication time between GPUs by allowing simultaneous processing of data in opposite directions. This approach minimizes the 'bubble' waiting time that occurs when GPUs wait for data to be copied. Additionally, they employed mixed precision training, which optimizes memory and training efficiency by reducing precision in less significant parts of the model while maintaining high precision where necessary. These methods align with the core principles of standard LLMs, such as those used in the Transformer architecture, by focusing on efficient data processing and model accuracy.",multi_hop_specific_query_synthesizer
What innovative methods did DeepSeek-V3 implement to reduce training inefficiencies and how do these methods relate to the overall performance of the model as described in the introduction?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek-V3 implemented several innovative methods to reduce training inefficiencies, particularly focusing on minimizing the 'bubble' waiting time during GPU communication. One key method is the DualPipe technique, which combines the forward process and the backward for input by initiating training data from two devices in opposite directions. This allows for continuous data processing and reduces communication delays between GPUs. Additionally, the model employs mixed precision training, where precision is reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. These methods contribute to the overall performance of DeepSeek-V3 by enabling economical training and enhancing efficiency, which is crucial for its success as an open-source model, as highlighted in the introduction of the paper.",multi_hop_specific_query_synthesizer
How does DeepSeek-V3 reduce communication between GPUs during training and what are its key features?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek-V3 reduces communication between GPUs during training by implementing the DualPipe method, which allows data to flow in opposite directions from two devices simultaneously. This innovation minimizes idle time for GPUs, enabling them to process different batches of data concurrently. Additionally, DeepSeek-V3 employs mixed precision training, where precision is reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter tasks. These techniques collectively enhance training efficiency and performance.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek-V3 implement to enhance training efficiency and performance, particularly in relation to the challenges posed by using H800 GPUs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek-V3 implemented several innovative methods to enhance training efficiency and performance, particularly when using the weaker H800 GPUs. One key method was the introduction of the DualPipe technique, which reduces communication time between GPUs by allowing simultaneous processing of training data in opposite directions. This approach minimizes idle time for GPUs and accelerates training. Additionally, DeepSeek-V3 utilized mixed precision training, where precision was reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. To address issues of overflow and underflow during quantization, DeepSeek employed Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating significantly. These methods collectively contributed to the model's impressive performance and economical training.",multi_hop_specific_query_synthesizer
What innovative methods did DeepSeek-V3 implement to enhance training efficiency and how do these methods relate to the model's performance as described in the introduction?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek-V3 implemented several innovative methods to enhance training efficiency, particularly through the use of the DualPipe technique and mixed precision training. The DualPipe method reduces communication time between GPUs by allowing simultaneous processing of data in opposite directions, which minimizes idle time and accelerates training. Additionally, mixed precision training optimizes memory and computational efficiency by selectively reducing precision in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter tasks. These methods contribute to the model's incredible performance and economical training, as they allow DeepSeek-V3 to achieve high efficiency even with weaker H800 GPUs, making it a competitive open-source model in the landscape of large language models.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement to enhance the training efficiency of LLMs like DeepSeek-V3, and how do these methods compare to traditional approaches?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek researchers implemented several innovative methods to enhance the training efficiency of LLMs, particularly with the DeepSeek-V3 model. One key method is the DualPipe technique, which reduces communication time between GPUs by allowing simultaneous training on multiple devices. This method combines the forward process and the backward for input by initiating training data from two devices in opposite directions, thus minimizing idle time and communication delays. Additionally, they employed mixed precision training, which improves training and memory efficiency by reducing the precision of less significant model parts while maintaining high precision for critical computations. This approach helps to mitigate issues like overflow and underflow through techniques such as Fine-Grained Quantization, where each group of values has its own scaling factor. These methods contrast with traditional approaches that often rely on high-performance GPUs and do not effectively address communication inefficiencies or precision management, making DeepSeek's strategies particularly advantageous for training LLMs on weaker hardware.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement to enhance the training efficiency of LLMs, particularly in the context of using weaker GPUs like the H800?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","DeepSeek researchers implemented several innovative methods to enhance the training efficiency of LLMs using weaker GPUs like the H800. One significant method was the introduction of the DualPipe technique, which reduces communication between GPUs by allowing data to flow in opposite directions simultaneously. This approach minimizes the waiting time, known as a 'bubble,' that occurs when GPUs wait for data to be copied from one another. Additionally, they employed mixed precision training, which optimizes training and memory efficiency by reducing the precision of less significant parts of the model while maintaining high precision for critical computations. To address issues of overflow and underflow during quantization, DeepSeek utilized Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating significantly. These methods collectively contributed to the economical training and impressive performance of the DeepSeek-V3 model.",multi_hop_specific_query_synthesizer
"How does the DeepSeek-V3 model utilize mixed precision training to enhance the efficiency of LLMs, and what are the key innovations introduced in its architecture?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model enhances the efficiency of LLMs through mixed precision training, which improves training and memory efficiency while maintaining model accuracy. In this approach, researchers identify parts of the model that are less significant for accuracy and reduce their precision, particularly in areas with heavy computations like matrix multiplication, while preserving high precision for lighter computations such as matrix addition. Additionally, the model incorporates innovations like Fine-Grained Quantization to mitigate issues of overflow and underflow during computation by applying unique scaling factors to grouped values. This allows for better representation within a limited range and prevents the accumulation of small errors, ensuring that the model achieves incredible performance and economical training as an open-source model.",multi_hop_specific_query_synthesizer
How does the DeepSeek-V3 model utilize mixed precision training to enhance the efficiency of LLMs?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.']","The DeepSeek-V3 model utilizes mixed precision training to improve training and memory efficiency while maintaining model accuracy. This technique involves identifying parts of the model that are less significant for accuracy and reducing their precision, particularly in areas with heavy computations like matrix multiplication. In contrast, high precision is preserved for lighter computations such as matrix addition and data storage. Additionally, to address issues of overflow and underflow that arise from quantization, DeepSeek implemented Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating significantly.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement in the DeepSeek-V3 model to enhance training efficiency, and how do these methods relate to the architecture of DeekSeek-V3?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented several innovative methods in the DeepSeek-V3 model to enhance training efficiency, particularly in the context of using weaker H800 GPUs. One key method is the DualPipe technique, which reduces communication time between GPUs by allowing simultaneous processing of data in opposite directions. This minimizes the 'bubble' waiting time that occurs when GPUs wait for data to be copied. Additionally, they employed mixed precision training, where precision is reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. This approach improves both training and memory efficiency. 

The architecture of DeekSeek-V3 builds upon these training techniques by incorporating a sophisticated Multi-Head Latent Attention (MLA) mechanism that compresses input data to improve speed and memory usage. The architecture also features a mixture of experts (DeekSeekMoE), where specialized experts are activated based on the input tokens, enhancing performance by allowing the model to focus on specific domains. Together, these methods and architectural innovations contribute to the overall efficiency and effectiveness of the DeepSeek-V3 model.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement in the DeekSeek-V3 model to enhance training efficiency, particularly in relation to the use of H800 GPUs and the architecture of the model?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented several innovative methods in the DeekSeek-V3 model to enhance training efficiency, especially given the limitations of H800 GPUs. They developed the DualPipe method to reduce communication time between GPUs, which is crucial since the training process involves significant data transfer. This method allows simultaneous training on multiple devices by initiating data processing in opposite directions, thus minimizing idle time and communication delays. Additionally, they employed mixed precision training, where they selectively reduced precision in computationally heavy parts of the model, like matrix multiplication, while maintaining high precision for lighter computations. This approach improves training and memory efficiency. Furthermore, the DeekSeek-V3 model architecture incorporates Multi-Head Latent Attention (MLA) to compress input data, enhancing speed and memory usage, and utilizes a mixture of experts (DeekSeekMoE) to allow specialized processing of tokens, improving overall model performance.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement to enhance model training efficiency with H800 GPUs, and how does the architecture of DeekSeek-V3 contribute to this?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented several innovative methods to enhance model training efficiency with H800 GPUs, primarily focusing on reducing communication time between GPUs. They introduced the DualPipe method, which allows simultaneous training of data from two devices in opposite directions, thereby minimizing idle time and communication delays. Additionally, they utilized mixed precision training to improve training and memory efficiency by selectively reducing precision in less significant parts of the model. The architecture of DeekSeek-V3 builds upon these methods by incorporating advanced components such as Multi-Head Latent Attention (MLA) and DeekSeekMoE, which enhance speed and memory usage in the attention block and allow for specialization among experts in the Feed-Forward Network. This combination of techniques and architectural improvements enables more efficient training and better performance of the model.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement to enhance model training efficiency with H800 GPUs, and how does this relate to the architecture of DeekSeek-V3?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented innovative methods to enhance model training efficiency with H800 GPUs by reducing communication between GPUs, which is crucial due to the limitations of these weaker GPUs. They introduced the DualPipe method, which allows simultaneous training of data from two devices in opposite directions, thereby minimizing idle time and communication delays. This method is essential for accelerating training processes. The architecture of DeekSeek-V3 builds upon these principles, incorporating advanced features like Multi-Head Latent Attention (MLA) and DeekSeekMoE, which improve speed and memory efficiency. The MLA compresses input data to enhance performance, while DeekSeekMoE utilizes a mixture of experts to specialize in different domains, further optimizing the model's efficiency.",multi_hop_specific_query_synthesizer
"What are the key innovations in the DeepSeek-V3 model that enhance training efficiency, and how do they compare to the architecture of DeekSeek-V3?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model introduces several key innovations to enhance training efficiency, particularly through its DualPipe method and mixed precision training. The DualPipe method reduces communication between GPUs by allowing simultaneous processing of data in opposite directions, which minimizes the waiting time or 'bubble' that occurs when using multiple GPUs. This is crucial for training on weaker H800 GPUs, as it accelerates the training process without needing to improve GPU speed. Additionally, mixed precision training is employed to optimize memory efficiency and maintain model accuracy by selectively reducing precision in less significant parts of the model, such as during heavy computations like matrix multiplication. On the other hand, the DeekSeek-V3 model builds upon the architecture of its predecessor, V2, by incorporating a Multi-Head Latent Attention (MLA) mechanism that compresses input data to improve speed and memory usage, and a mixture of experts (DeekSeekMoE) that allows specialized processing of tokens. While both models aim to enhance performance, DeepSeek-V3 focuses on training efficiency through innovative methods, whereas DeekSeek-V3 emphasizes architectural improvements for better processing capabilities.",multi_hop_specific_query_synthesizer
"What innovative methods did DeepSeek researchers implement in the DeekSeek-V3 model to enhance training efficiency, particularly in relation to the challenges posed by using weaker H800 GPUs?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented several innovative methods in the DeekSeek-V3 model to enhance training efficiency while using weaker H800 GPUs. One key method was the introduction of DualPipe, which reduces communication between GPUs by allowing simultaneous training of different batches of data in opposite directions. This approach minimizes the waiting time, known as 'bubble,' that occurs when GPUs wait for data to be copied. Additionally, the model employs mixed precision training, where precision is reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. To address issues of overflow and underflow during quantization, DeepSeek implemented Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating. These techniques collectively improve training speed and memory efficiency, making the most of the available hardware.",multi_hop_specific_query_synthesizer
What innovative methods did DeepSeek researchers implement in the DeekSeek-V3 model to enhance training efficiency with weaker GPUs?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented several innovative methods in the DeekSeek-V3 model to enhance training efficiency with weaker H800 GPUs. One key method was the introduction of DualPipe, which reduces communication between GPUs by allowing simultaneous training of different batches of data in opposite directions. This minimizes the waiting time, known as 'bubble,' that occurs when GPUs wait for data to be copied. Additionally, they employed mixed precision training, where they reduced precision in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. To address issues of overflow and underflow during quantization, they implemented Fine-Grained Quantization, allowing each group of values to have its own scaling factor, thus preventing errors from accumulating. These techniques collectively improved the training speed and efficiency of the DeekSeek-V3 model.",multi_hop_specific_query_synthesizer
What innovative methods did DeepSeek researchers implement in the DeekSeek-V3 model to enhance training efficiency and how do these methods relate to the architecture of the model?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented several innovative methods in the DeekSeek-V3 model to enhance training efficiency. One key method is the DualPipe technique, which reduces communication between GPUs during model training. By allowing data to flow in both forward and backward processes simultaneously from two devices, it minimizes the waiting time, known as 'bubble,' that occurs when GPUs wait for data. This is particularly important given that the model was trained on weaker H800 GPUs. Additionally, the model employs mixed precision training, where precision is reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. This approach improves training and memory efficiency while preserving model accuracy. The architecture of DeekSeek-V3 builds upon the previous V2 model, incorporating a sophisticated Multi-Head Latent Attention (MLA) mechanism that compresses input data to improve speed and memory usage. Furthermore, the model features a mixture of experts (DeekSeekMoE) in its Feed-Forward Network, allowing specialized processing of input tokens, which enhances performance. Together, these methods and architectural innovations contribute to the overall efficiency and effectiveness of the DeekSeek-V3 model.",multi_hop_specific_query_synthesizer
"What are the key innovations in the DeepSeek-V3 model that differentiate it from its predecessor, DeekSeek-V2, particularly in terms of architecture and training efficiency?","['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model incorporates several key innovations that enhance its architecture and training efficiency compared to the DeekSeek-V2 model. Firstly, it utilizes a Multi-Head Latent Attention (MLA) mechanism, which compresses the input vector to improve speed and memory usage in the attention block. This compression allows for a more economical key-value (KV) cache, reducing data copying and enhancing memory efficiency. Secondly, the architecture features a split Feed-Forward Network known as DeekSeekMoE, where multiple experts specialize in different domains of tokens, improving performance by activating only the relevant experts based on the input sequence. Additionally, DeepSeek-V3 employs a sequential Multi-Token Prediction (MTP) approach, which constructs independent MTP modules to generate multiple tokens efficiently, leading to faster convergence during training. These innovations collectively contribute to the model's enhanced performance and efficiency.",multi_hop_specific_query_synthesizer
What innovative methods did DeepSeek researchers implement in the DeekSeek-V3 model to enhance training efficiency and reduce communication between GPUs?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented several innovative methods in the DeekSeek-V3 model to enhance training efficiency and reduce communication between GPUs. One key method is the DualPipe technique, which combines the forward process and the backward for input by initiating training data from two devices in opposite directions. This approach allows for continuous data copying and reduces idle time for GPUs, thereby minimizing communication delays. Additionally, the model employs mixed precision training, where precision is reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. This strategy improves training and memory efficiency while addressing issues of overflow and underflow through Fine-Grained Quantization, which assigns individual scaling factors to groups of values to prevent quantization errors.",multi_hop_specific_query_synthesizer
What innovative methods did DeepSeek researchers implement in the DeekSeek-V3 model to enhance training efficiency and reduce communication time between GPUs?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek researchers implemented several innovative methods in the DeekSeek-V3 model to enhance training efficiency and reduce communication time between GPUs. One key method is the DualPipe technique, which combines the forward process and the backward for input by initiating training data from two devices in opposite directions. This allows for continuous data copying and reduces idle time for GPUs, thereby minimizing communication delays. Additionally, they employed mixed precision training, where they reduced precision in parts of the model that are less significant for accuracy, such as matrix multiplication, while preserving high precision for lighter computations. This approach improves training and memory efficiency. Furthermore, they introduced Fine-Grained Quantization to mitigate overflow and underflow issues during lower precision computations, ensuring that values are represented accurately without significant error accumulation.",multi_hop_specific_query_synthesizer
What are the key innovations in DeepSeek-V3 that improve training efficiency compared to previous models like DeekSeek-V2?,"['<1-hop>\n\nInfrastructure 3.1 DualPipe Since the U.S. did not export great GPUs like the NVIDIA H100 to China, DeepSeek researchers had to devise innovative methods to accelerate model training using the weaker H800 GPUs. Since they succeeded, NVIDIA’s stock price briefly plunged, as people believed that high-performance GPUs would no longer be necessary for training LLM. Because the DeepSeek model was trained on 2048 H800 GPUs, communication between GPUs accounts for large portion of training time. Therefore, enhanching networking between GPUs has to play crucial role to reduce training time. When we use many GPUs simultaneously, the GPUs have to wait for a certain amount of time until new data is copied from other GPU. This waiting time, which causes training inefficiencies, is known as a “bubble,” and we should minimize it as much as possible. DeepSeek invented a innovative method to reduce bubble. During model training, data flows through the model in forward and backward processes. In forward process, data goes from the input layer to the output layer. On the other hand, during the backward process data moves from the output layer to the input later, updating weights based on the information to minimize the loss. Prior to DeepSeek, researchers found that the backward process can be split into two processes, which are backward for input and backward for weight, in order to remove more bubbles. The backward for input is computation of the gradient of the loss with respect to the input data, whereas the backward for weight calculates gradient of the loss with respect to the weight. The backward for input must be completed ahead of the backward for weight, because it is necessary to compute the backward for weight. Mathematically, the chain rule is applied to the calculation of backpropagation, where the backward for input is used for the calculation of backward for weight. In such process, it is certain that an enormous number of communications between GPUs is required. In order to reduce the number of communication, the DeepSeek’s DualPipe combines the forward process and the backward for input by initiating training data from two devices in the opposite directions as illustrated in following figure. The batch 0 is the initial data, which starts processing on the device 0 and continues on the subsequent devices. In a conventional training plan, the device 7 remains idle, waiting for the batch 0 to be copied onto it. However, DualPipe makes the device 7 start training with other batch data in the opposite direction. This allows us to combine them as a chunk and continuously copy them together on other devices to reduce communication between GPUs. With weaker H800 GPUs, they couldn’t improve the speed of the GPUs, but reduce the communication between GPUs to accelerate the training. 3.2 Mixed precision training Mixed precision training is already prevalent technique of LLM to improve training and memory efficiency while maintaining the model accuracy. In mixed precision training, it is critical task to find out which parts of model are less significant for the model accuracy and reduce the precision that parts. In DeepSeek-V3 model, the researchers have found that they should reduce precision in the parts of model where heavy computations are executed, such as matrix multiplication. In contrast, they preserved high precision for matrix addition and storing data, which are relatively lightweight computation. The mixed precision training of DeepSeek is shown in the following figure. While reducing the precision by the method above, overflow and underflow arise as a impediment. If the numerical values are quantized in lower precision like FP8 format, the values are clipped to the certain representable range. While computation in lower precision, the values can easily exceed the range during the computation. Scaling the values can mitigate the overflow and underflow by adjusting the values and lead to more proper representation in limited range. But, static scaling, which applies fixed scaling factor to all values, can still cause overflow and underflow for many values. To cope with this issue, DeepSeek implemented Fine-Grained Quantization. In this method, the values are grouped, and each group has its own scaling factor. This approach allows the each group of values to have a more suitable scaling factor, by which the overflow and underflow can be averted. Another issue of quantization is that the small errors can be accumulated and become more serious problem later. In order to avoid that a lot of values with error are summed and their errors are accumulated, intermediate values are copied in high precision, if the number of values reaches the interval. It means that some values are grouped, and their values are stored in high precision. Then, the errors of values aren’t accumulated on a large scale, because the small group of values don’t contribute to large error. These two techniques to prevent quantization error are visualized in following figure.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","DeepSeek-V3 introduces several key innovations to improve training efficiency. Firstly, it employs a method called DualPipe, which reduces communication between GPUs by allowing simultaneous training on multiple devices in opposite directions. This minimizes the waiting time, or 'bubble', that occurs when GPUs wait for data. Secondly, it utilizes mixed precision training, where precision is reduced in less significant parts of the model, such as during heavy computations like matrix multiplication, while maintaining high precision for lighter computations. Additionally, DeepSeek-V3 incorporates Fine-Grained Quantization to prevent overflow and underflow during computations by using group-specific scaling factors. Lastly, the model architecture has been enhanced with Multi-Head Latent Attention (MLA) and DeekSeekMoE, which improve speed and memory efficiency by compressing input data and utilizing a mixture of experts for specialized processing.",multi_hop_specific_query_synthesizer
What are the key architectural features of the DeepSeek-V3 model that contribute to its performance and how does it differ from the previous V2 model?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model achieves its performance through several key architectural features. Firstly, it inherits most parts from the previous V2 model, maintaining the structure of the ordinary transformer block similar to LLaMA. However, it enhances the attention mechanism with Multi-Head Latent Attention (MLA), which improves speed and memory usage by compressing the input vector. This compression allows for a more economical KV cache while preserving information. Secondly, the Feed-Forward Network (FFN) is split into multiple experts, termed DeekSeekMoE, allowing specialization in certain domains, which enhances performance. Each expert is activated based on the input sequence, contributing to the output based on their specialized knowledge. Additionally, DeepSeek introduces a sequential Multi-Token Prediction (MTP) method, which constructs independent MTP modules to improve efficiency and speed of convergence during training, contrasting with the previous parallel MTP approach.",multi_hop_specific_query_synthesizer
"How does the DeekSeek-V3 model improve training efficiency and performance compared to its predecessor, and what are the key features that contribute to this advancement?","['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeekSeek-V3 model improves training efficiency and performance compared to its predecessor by incorporating several key features. Firstly, it utilizes Multi-Head Latent Attention (MLA), which enhances speed and memory usage in the attention block by compressing the input vector, allowing for more efficient data processing. This compression is achieved through techniques like Principal Component Analysis (PCA) and variational autoencoders, which help maintain information while reducing dimensionality. Secondly, the model introduces DeekSeekMoE, a split Feed-Forward Network that consists of multiple experts specializing in different domains. This allows the model to activate only the relevant experts based on the input tokens, improving performance by leveraging specialized knowledge. Additionally, the model employs a sequential Multi-Token Prediction (MTP) approach, which constructs independent MTP modules to generate multiple tokens efficiently, leading to faster convergence during training. These innovations collectively contribute to the remarkable performance and economical training of the DeekSeek-V3 model.",multi_hop_specific_query_synthesizer
How does the architecture of the DeepSeek-V3 model relate to previous models like LLaMA and what are the key features that enhance its performance?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The architecture of the DeepSeek-V3 model relates to previous models like LLaMA in that it uses the structure of the ordinary transformer block, which is a common foundation for many large language models. However, DeepSeek-V3 enhances its performance through sophisticated components such as Multi-Head Latent Attention (MLA) and DeekSeekMoE. The MLA improves speed and memory usage by compressing the input vector, while DeekSeekMoE allows for a mixture of experts to specialize in certain domains, thus optimizing the model's output based on the input tokens. These innovations contribute to the model's economical training and impressive performance.",multi_hop_specific_query_synthesizer
"How does the architecture of the DeepSeek-V3 model, which builds upon principles similar to LLaMA, enhance its performance through features like Multi-Head Latent Attention and DeekSeekMoE?","['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The architecture of the DeepSeek-V3 model enhances its performance by incorporating features like Multi-Head Latent Attention (MLA) and DeekSeekMoE, while building upon principles similar to LLaMA. The MLA improves speed and memory usage in the attention block by compressing the input vector, allowing for efficient data processing. This compression is achieved through techniques like Principal Component Analysis (PCA), which maintains information while reducing dimensionality. Additionally, the DeekSeekMoE splits the Feed-Forward Network into multiple experts, each specializing in certain domains, which allows for more efficient processing of input tokens. This mixture of experts approach enables the model to activate only the relevant experts based on the input, thereby improving overall performance and efficiency.",multi_hop_specific_query_synthesizer
"What are the key architectural features of the DeepSeek-V3 model that differentiate it from previous models like LLaMA, particularly in terms of its attention mechanism and multi-token prediction capabilities?","['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model incorporates several key architectural features that differentiate it from previous models like LLaMA. Firstly, it utilizes a Multi-Head Latent Attention (MLA) mechanism, which improves speed and memory usage by compressing the input vector, allowing for more efficient processing. This is achieved through techniques such as Principal Component Analysis (PCA) for dimensionality reduction while preserving information. Additionally, the Feed-Forward Network (FFN) in DeepSeek-V3 is split into multiple experts, known as DeekSeekMoE, allowing specialization in certain domains, which enhances performance. Each expert is activated based on the similarity of the input tokens to their specialized domain. Furthermore, DeepSeek-V3 introduces a sequential Multi-Token Prediction (MTP) approach, which constructs independent MTP modules to generate multiple tokens efficiently, contrasting with the traditional method of generating one token at a time. This sequential approach allows for better information flow and faster convergence during training.",multi_hop_specific_query_synthesizer
"What are the similarities between the architecture of the DeepSeek-V3 model and LLaMA, particularly in terms of the attention mechanism?","['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The architecture of the DeepSeek-V3 model shares similarities with LLaMA in that it uses the structure of the ordinary transformer block. Both models incorporate an attention mechanism, but the DeepSeek-V3 model enhances this with a more sophisticated approach called Multi-Head Latent Attention (MLA). This improvement boosts model performance by compressing the input vector, which helps in speeding up the attention block and improving memory usage.",multi_hop_specific_query_synthesizer
What are the key architectural features of the DeepSeek-V3 model that contribute to its performance and how do they compare to the previous V2 model?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model achieves its performance through several key architectural features that build upon the previous V2 model. Firstly, it utilizes a structure similar to the ordinary transformer block, incorporating Multi-Head Latent Attention (MLA) and DeepSeekMoE. The MLA enhances speed and memory efficiency by compressing the input vector, allowing for improved performance while maintaining information integrity. This is achieved through techniques like Principal Component Analysis (PCA) and variational autoencoders. Secondly, the DeepSeekMoE splits the Feed-Forward Network into multiple experts, allowing specialization in certain domains, which enhances performance by activating only the relevant experts based on the input tokens. This contrasts with the V2 model, where the architecture was less sophisticated in handling token specialization. Additionally, DeepSeek-V3 introduces a sequential Multi-Token Prediction (MTP) method, which improves training efficiency by allowing the model to generate multiple tokens in a structured manner, unlike the previous parallel MTP approach. Overall, these innovations in DeepSeek-V3 significantly boost its performance and training economy compared to its predecessor.",multi_hop_specific_query_synthesizer
"How does the DeekSeek-V3 model improve training efficiency compared to traditional methods, and what role does Multi-Head Latent Attention play in this?","['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeekSeek-V3 model improves training efficiency by utilizing Multi-Head Latent Attention (MLA), which enhances speed and memory usage in the attention block by compressing the input vector. This compression allows for a more economical KV cache, reducing data copying and memory requirements. Additionally, the model employs a mixture of experts (DeekSeekMoE) to specialize in certain domains, further optimizing performance. Together, these features contribute to a more efficient training process compared to traditional methods.",multi_hop_specific_query_synthesizer
"What are the key architectural features of the DeepSeek-V3 model that differentiate it from previous models like LLaMA, particularly in terms of efficiency and performance?","['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model incorporates several key architectural features that enhance its efficiency and performance compared to previous models like LLaMA. Firstly, it utilizes a Multi-Head Latent Attention (MLA) mechanism, which improves speed and memory usage by compressing the input vector, allowing for more efficient data processing. Additionally, the model employs a unique Feed-Forward Network called DeekSeekMoE, which splits the network into multiple experts that specialize in certain domains, thereby optimizing performance based on the input tokens. This mixture of experts approach allows for targeted activation of specific experts, enhancing the model's ability to handle diverse token ranges. Furthermore, DeepSeek introduces a sequential Multi-Token Prediction (MTP) method, which constructs independent MTP modules to generate multiple tokens efficiently, leading to faster convergence during training. These innovations collectively contribute to the model's remarkable performance and economical training as an open-source model.",multi_hop_specific_query_synthesizer
How does the DeekSeek-V3 model utilize principles from LLaMA and Llama to enhance its performance and training efficiency?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeekSeek-V3 model utilizes principles from LLaMA and Llama by inheriting the structure of the ordinary transformer block, which is a common architecture in large language models. While it maintains this foundational structure, DeekSeek-V3 enhances its performance through sophisticated components like Multi-Head Latent Attention (MLA) and a mixture of experts (DeekSeekMoE). The MLA improves speed and memory usage by compressing input vectors, while the DeekSeekMoE allows the model to specialize in certain domains, activating specific experts based on the input tokens. This combination of techniques leads to more economical training and improved model performance.",multi_hop_specific_query_synthesizer
"What are the similarities between the architecture of the DeepSeek-V3 model and LLaMA, particularly in terms of the transformer block structure?","['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The architecture of the DeepSeek-V3 model shares similarities with LLaMA in that it utilizes the structure of the ordinary transformer block. Both models incorporate sophisticated components to enhance performance, with DeepSeek-V3 employing Multi-Head Latent Attention (MLA) and a unique Feed-Forward Network called DeekSeekMoE. While LLaMA's architecture is foundational, DeepSeek-V3 builds upon it by improving speed and memory efficiency through compression techniques and specialized expert networks.",multi_hop_specific_query_synthesizer
How does the DeekSeek-V3 model relate to LLaMA and what improvements does it offer in terms of model architecture?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeekSeek-V3 model relates to LLaMA in that it uses a similar structure based on the ordinary transformer block. However, DeekSeek-V3 introduces enhancements such as Multi-Head Latent Attention (MLA) and a unique Feed-Forward Network called DeekSeekMoE, which splits the network into multiple experts to improve performance. These improvements allow for better speed and memory efficiency, as well as more specialized processing of input tokens, compared to the standard architecture used in LLaMA.",multi_hop_specific_query_synthesizer
How does the architecture of the DeepSeek-V3 model compare to LLaMA in terms of efficiency and performance?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The architecture of the DeepSeek-V3 model, while built upon the principles of the standard Transformer and similar to LLaMA, incorporates advanced features to enhance efficiency and performance. Specifically, DeepSeek-V3 utilizes Multi-Head Latent Attention (MLA) to improve speed and memory usage by compressing input vectors, which is a departure from the conventional attention module. Additionally, the model employs a mixture of experts (DeekSeekMoE) in its Feed-Forward Network, allowing for specialization in certain domains, which further boosts performance. This sophisticated architecture aims to achieve economical training and improved model performance compared to earlier models like LLaMA.",multi_hop_specific_query_synthesizer
What are the key architectural features of the DeepSeek-V3 model that contribute to its performance and how does it differ from the previous V2 model?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model achieves its performance through several key architectural features. It inherits most parts from the previous V2 model, maintaining the structure of the ordinary transformer block similar to LLaMA. However, it enhances the attention mechanism with Multi-Head Latent Attention (MLA), which improves speed and memory usage by compressing the input vector. This compression allows for a more economical KV cache while preserving information. Additionally, the Feed-Forward Network (FFN) is split into multiple experts, termed DeekSeekMoE, allowing specialization in certain domains, which improves performance. Each expert is activated based on the input sequence, contributing to the output based on their specialized knowledge. Furthermore, DeepSeek introduces a sequential Multi-Token Prediction (MTP) method, which constructs independent MTP modules to enable the generation of multiple tokens, enhancing efficiency and convergence during training. This contrasts with the previous V2 model, which did not implement these advanced features.",multi_hop_specific_query_synthesizer
"In what ways does the architecture of the DeepSeek-V3 model build upon the principles of previous models like LLaMA, and how does it enhance performance through features such as Multi-Head Latent Attention and DeekSeekMoE?","['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The architecture of the DeepSeek-V3 model builds upon the principles of previous models like LLaMA by inheriting most parts from the earlier V2 model, which utilized the structure of the ordinary transformer block. However, DeepSeek-V3 enhances performance through innovative features such as Multi-Head Latent Attention (MLA) and DeekSeekMoE. MLA improves speed and memory usage in the attention block by compressing the input vector, allowing for efficient data processing while retaining essential information. This is achieved by applying techniques similar to Principal Component Analysis (PCA) for dimensionality reduction. On the other hand, DeekSeekMoE introduces a mixture of experts approach, where the Feed-Forward Network is split into multiple specialized experts. This allows the model to activate only those experts that are relevant to the input tokens, thereby improving performance by focusing on specific domains. Together, these features contribute to the model's economical training and enhanced performance.",multi_hop_specific_query_synthesizer
What are the key architectural features of the DeepSeek-V3 model that contribute to its performance and how does it differ from the previous V2 model?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model achieves its performance through several key architectural features. It inherits most parts from the previous V2 model, maintaining the structure of the ordinary transformer block similar to LLaMA. However, it enhances the attention mechanism with Multi-Head Latent Attention (MLA), which improves speed and memory usage by compressing the input vector. This compression allows for a more economical KV cache while preserving information. Additionally, the Feed-Forward Network (FFN) is split into multiple experts, termed DeekSeekMoE, allowing specialization in certain domains, which improves performance. This mixture of experts activates specific experts based on the input sequence, enhancing the model's efficiency. Furthermore, DeepSeek-V3 introduces a sequential Multi-Token Prediction (MTP) method, which constructs independent MTP modules to enable the generation of multiple tokens, thus improving learning efficiency and convergence speed compared to traditional methods.",multi_hop_specific_query_synthesizer
What are the key features of the DeepSeek-V3 model that contribute to its performance and how does the DeekSeekMoE mechanism enhance its efficiency?,"['<1-hop>\n\nauthor - Ataka jeong Introduction How could the DeepSeek-V3 model achieve incredible performance and economical training as an open source model? In this paper review, we will explore the various features that were invented and applied to build the DeepSeek-V3 model. The way the paper presents the model may seem complicated to people who are unfamiliar with the new conceptualization invented by DeepSeek. However, its core principle still resembles that of the standard Transformer and well-known LLMs. It will be incredibly helpful to have general knowledge of previously released large language models like LLaMA. I will also add my own interpretation of the DeekSeek model in this story. Let’s dive into the new features of model architecture step by step.', '<2-hop>\n\nModel Architecture First of all, we will investigate the core architecture of DeekSeek-V3 model. The DeekSeek-V3 model has inherited most parts of model from previous V2 model. These parts of model were elaborated more in V2 paper, but it is worth noting the principle how V3 model was built upon. While they used the structure of the ordinary transformer block like Llama, its attention and Feed-Forward Network were more sophisticated to boost the model performance. The overview of the Transformer block is as shown in the following diagram. The two main components are Multi-Head Latent Attention(MLA) and DeepSeekMoE. 2.1 Multi-Head Latent Attention(MLA) What is Multi-Head Latent Attention(MLA)? You might noticed that “Latent” is only additional word to conventional attention module. MLA improved the speed and memory usage in the attention block by compressing the input vector. From a data analysis perspective, the data can be compressed into a lower dimension while preserving the information it contains. One of the well-known techniques is Principal component analysis (PCA), which reduces the dimension of the data and maintains variance to retain its information. In latent diffusion model, the input data is compressed by variational autoencoder and reconstructed in initial dimension. The Multi-Head Latent Attention(MLA) applied this principle to compress and decompress the input data. By storing a compressed vector for the KV cache, the DeepSeek model can improve both speed by reducing data copying and memory efficiency by using a smaller compressed vector. The weight matrix for compression is additionally required, because human cannot compress it manually, but AI should learn it how the compression should be done. Applying RoPE to the compressed vector is not mathematically compatible, which was shown in detail in V2 paper, they used decoupled RoPE. As illustrated in the figure above, RoPE is applied to query and key, but also the query and key without RoPE. The RoPE-applied query and key are then concatenated with their respective non-RoPE counterparts. Finally, the query and key are obtained as normal transformer block, then the computation of dot-product attention will not be different from original one. But we could reach this point with a more economical KV cache thanks to the lower dimension of data. 2.2 DeekSeekMoE Secondly, you can note that Feed-Forward Network is unusual as it was split into a lot of experts, rather than one large FFN. They called it as DeekSeekMoE. Like humans in a group, the AI also needs to specialized in certain domain to improve the performance. Thus, the mixture of experts come into play here. Each expert can specialize in certain domain, in this case, the group of tokens that they are familiar with, instead of coping with entire range of tokens alone. Dependent on the input sequence(tokens), the certain experts are selected to be activated and they contribute to make output. Shared experts are generalist and are activated for all kind of tokens. Then it might be interesting to know by what algorithm we can select the experts? We need to assign a vector to each expert which determines the range of tokens(domain) that experts can deal with well. And we give score to each expert to check how similar the domain of expert and input token are. If the score is high, then we should select the expert and let them activated to make output. Well, it sounds quite simple. Let’s see the math behind it. eᵢ is a centroid vector. It is learned during training and represents the type of input tokens the expert specialized in. Each expert’s centroid vector encodes the knowledge domain it specializes in. uₜ is input vector to FFN. The dot product uₜᵀ eᵢ quantifies the similarity between the input vector uₜ\u200b and the centroid (or domain) of expert eᵢ, effectively measuring the alignment of the input data with the expert’s specialized domain. So, the sᵢ = Sigmoid(uₜᵀ eᵢ) represents the score for each i-th expert, determining whether the expert should be selected. By gating value gᵢ, which select Kᵣ experts with high score by Topk algorithm. We add all outputs of selected experts and shared experts, then we arrive to the final output. 2.3 Multi-Token Prediction In a standard transformer, the model generates a token each time, and this new token is fed back into decoder as input. Since this way restricts the efficiency and the speed of convergence during training, many researchers have made effort to come up with a method to generate multiple tokens each time. DeepSeek improved the conventional way of Multi-Token Prediction(MTP). Instead of previous parallel MTP, DeepSeek decided sequential MTP. They construct independent MTP modules, where the previous output of the Transformer block is concatenated into the subsequent MTP module, as illustrated in the following figure. As shown in the figure, the structure of MTP modules is akin to RNN model. But, unlike RNN, which preserve hidden states of nodes, the MTP modules send output of prediction to the subsequent module. Even though a single Transformer block cannot generate multiple tokens, the entire system of MTP modules collectively enables multi-token prediction. As it compares additional tokens per prediction, it provides more information for weight updates during training, leading to more efficient learning and faster convergence. The model can proactively learn and prepare for the additional tokens. In actual training, DeepSeek opted to generate only one additional token, presumably due to the computational cost which is caused by using many MTP modules. It necessitate the compromise between the benefits of MTP and computational cost. During inference, the MTP modules are discarded, generating only one token per prediction.']","The DeepSeek-V3 model achieves incredible performance and economical training through several key features. Firstly, it builds upon the standard Transformer architecture, incorporating advanced components like Multi-Head Latent Attention (MLA) and DeekSeekMoE. The MLA improves speed and memory usage by compressing the input vector, allowing for efficient data processing while retaining essential information. This is achieved through techniques like Principal Component Analysis (PCA) and variational autoencoders. Secondly, the DeekSeekMoE mechanism enhances efficiency by splitting the Feed-Forward Network into multiple experts, each specializing in certain domains of tokens. This allows for selective activation of experts based on the input sequence, improving performance by leveraging specialized knowledge. The model also implements a Multi-Token Prediction (MTP) approach, which, although sequential, allows for more efficient learning and faster convergence during training.",multi_hop_specific_query_synthesizer
